#!/bin/bash
# Άσκηση 3 - Καταμέτρηση λέξεων σε βιβλία

# Αναζήτηση για παράμετρο -h ή --help.
# Άν το grep δεν επιστρέψει κενό, τότε βρέθηκε κάποιο από τα δύο και πρέπει να εμφανίσω
#   μήνυμα βοήθειας και να κάνω έξοδο του script.
for arg in $@; do
    grep_res=`echo $arg | grep -E "^((\-h)|(\-\-help))$"`
    if [ "$grep_res" != "" ]; then
        # Βρέθηκε κάτι από τα δύο: Εμφανίζω μήνυμα και έχω έξοδο από το script.
        echo "Χρήση: script3.sh ΟΝΟΜΑ_ΑΡΧΕΙΟΥ ΑΡΙΘΜΟΣ_N"
        echo "Aναλύει το βιβλίο με όνομα ΟΝΟΜΑ_ΑΡΧΕΙΟΥ, και παρουσιάζει στο χρήστη τις ΑΡΙΘΜΟΣ_N λέξεις που εμφανίζονται
    πιο συχνά στο βιβλίο και τις παρουσιάζει σε φθίνουσα σειρά εμφάνισης"
        echo "Παράδειγμα χρήσης: ./script3.sh mybook.txt 4"
        exit 0
    fi
done

# Μέτρηση γραμμών κειμένου και απομόνωση του αριθμού από το αποτέλεσμα της wc
len=$(wc -l $1 | sed "s/\([0-9][0-9]*\) .*/\1/g");

# Εύρεση και απομόνωση του αριθμού της προηγούμενης γραμμής 
#   από όπου ξεκινάει πρακτικά το βιβλίο 
begin=$(grep -n "\*\*\* START OF THIS PROJECT GUTENBERG EBOOK" $1 | sed "s/:.*//")

# Εύρεση και απομόνωση του αριθμού της επόμενης γραμμής 
#   από όπου τελειώνει πρακτικά το βιβλίο 
end=$(grep -n "\*\*\* END OF THIS PROJECT GUTENBERG EBOOK" $1 | sed "s/:.*//")

# Επεξεργασία του "καθαρού" κειμένου του βιβλίου και εκτύπωση του αποτελέσματος.
# Βήματα επεξεργασίας:
#   01. Μεταφορά του κειμένου στο stdout
#   02. Αποκοπή του τμήματος του κειμένου πρίν το πραγματικό κείμενο
#   03. Αποκοπή του τμήματος του κειμένου μετά το πραγματικό κείμενο
#   04. Διαχωρισμός κάθε λέξης σε ξεχωριστή γραμμή
#   05. Μετατροπή κεφαλαίων σε πεζά (ώστε να μην διαχωρίζει μεταξύ κεφαλαίων/πεζών)
#   06. Από τις σύνθετες λέξεις που χωρίζονται με αποστρόφους τύπου xxxx'y, διαγραφή του μέρους y μετά το ' και του '.
#   07. Μετατροπή σημείων στήξης σε αλλαγή γραμμής ώστε αφενός να διαγραφούν εκείνα και αφετέρου να ξεχωρίσουν και οι λέξεις που
#           χωρίζονται με αυτά.
#   08. Διαγραφή των σημείων στήξης και λευκών χαρακτήρων που παρέμειναν.
#   09. Διαγραφή γραμμών που αποτελούνται μόνο από λευκούς χαρακτήρες (κενές γραμμές).
#   10. Ταξινόμηση λέξεων.
#   11. Μέτρηση μοναδικών λέξεων.
#   12. Αντικατάσταση των "  " με "00" στην αρχή της εξόδου της uniq, ώστε να μπορεί να γίνει ταξινόμηση αργότερα.
#   13. Αντικατάσταση του (πιθανού) κενού με 0 πρίν τον αριθμό εμφανίσεων της λέξης στην έξοδο της uniq για τον ίδιο λόγο.
#   14. Ταξινόμηση των λέξεων σε φθίνουσα σειρά εμφάνισης.
#   15. Διαγραφή των περιττών 0 που προστέθηκαν προηγουμένως.
#   16. Μορφοποίηση της σειράς των λέξεων κάθε γραμμής, ώστε να εμφανίζεται πρώτα η λέξη και μετά ο αριθμός εμφανίσεων.
#   17. Εμφάνιση των $2 λέξεων πιο συχνά στο βιβλίο.
cat $1 | tail -n $(($len - $begin)) | head -n $(( $(( $len - $begin)) - $(( $len - $end)) - 1)) | tr ' ' '\n' | tr '[:upper:]' '[:lower:]' | sed "s/\([a-z][a-z]*\)'[a-z]/\1/g" | tr "[:punct:]" "\n" | sed "s/]*[\.\,\?\;\!\:\t\(\)\_\"\[]*[[:space:]]*-*//g" | sed "/^[[:space:]]*$/d" | sort | uniq -c -i | sed "s/  /00/g" | sed "s/[[:space:]]\([1-9][0-9]*[[:space:]]\)/0\1/g" | sort -r | sed "s/^0*//g" | sed "s/\([0-9]*\) \(.*\)/\2 \1/" | head -n $2
